from __future__ import annotations

import importlib.resources
from collections.abc import Callable
from typing import Any, Union

import numpy as np
from numpy.typing import NDArray
from scipy.interpolate import interp1d  # type: ignore[import-untyped]

from . import beam_data

Numeric = Union[np.int32, np.int64, np.float32, np.float64]


arcmin_to_rad = np.radians(1 / 60)

#####################################
#         DEFINE kSZ BEAM           #
#####################################


def beam_transform_to_profile(
    B_ell: NDArray[Numeric], theta: NDArray[Numeric], normalize: bool = False
) -> Any:
    """
    Given the transform B(l) of a beam, evaluate its real space angular profile
    at a given an angle theta in radians. This code is adapted from the pixell
    library under the utils.py module.

    Parameters
    ----------
    B_ell : np.array
        The multipole transform of the beam.
    theta : np.array or float
        The angle in radians at which to evaluate the beam profile.
    normalize : bool
        If True, normalize the beam profile.

    Returns
    -------
    profile : np.array or float
        The beam profile at the given angle theta.
    """
    # check to make sure B_ell is an array
    B_ell = np.asarray(B_ell)

    # multipole moments
    ell = np.arange(B_ell.size)

    # cosine of the angle for legendre polynomials
    x = np.cos(theta)

    # c_ell coefficients
    coefficients = B_ell * (2 * ell + 1) / (4 * np.pi)

    # evaluate the Legendre polynomial at the given angle
    profile = np.polynomial.legendre.legval(x, coefficients)  # type: ignore[no-untyped-call]

    if normalize:  # pragma: no cover
        profile /= np.sum(coefficients)

    return profile


def generate_beam_profile(
    frequency: str, space: str = "real"
) -> Callable[[NDArray[Numeric]], NDArray[Numeric]]:
    """
    This function generates the beam profile for a given frequency. The beam profile
    is generated by transforming the beam from the multipole space to the real space
    angular profile. The beam profile returned is a function of the angle theta in radians.

    Parameters
    ----------
    frequency : str
        The frequency of the beam. Can be either 'f150' or 'f090'.
    space : str
        The space in which to return the beam profile. Can be either 'real' or 'harmonic'.

    Returns
    -------
    profile_func : function
        The beam profile as a function of the angle theta in radians.
    """

    if frequency == "f150":
        beam_file = "act_planck_dr5.01_s08s18_f150_daynight_beam.txt"
    elif frequency == "f090":
        beam_file = "act_planck_dr5.01_s08s18_f090_daynight_beam.txt"
    else:  # pragma: no cover
        msg = "Frequency must be either 'f150' or 'f090'"
        raise ValueError(msg)

    beam_file = importlib.resources.files(beam_data) / beam_file  # type: ignore[attr-defined]

    # load the beam transform
    ell, B_ell = np.loadtxt(beam_file, unpack=True)

    if space == "real":
        # define theta array used for interpolation
        theta = np.linspace(0, 100, 1000) * arcmin_to_rad  # radians

        # generate profile
        profile = beam_transform_to_profile(B_ell, theta)

        # normalize the profile
        integral = np.trapz(profile * 2 * np.pi * theta, x=theta)

        # interpolate the profile
        def profile_func(theta: NDArray[Numeric]) -> NDArray[Numeric]:
            return np.interp(theta, theta, profile / integral, period=np.pi)

    elif space == "harmonic":
        profile_func = interp1d(
            ell, B_ell, kind="linear", bounds_error=False, fill_value=0.0
        )
    else:  # pragma: no cover
        msg = "Space must be either 'real' or 'harmonic'"
        raise ValueError(msg)

    return profile_func
